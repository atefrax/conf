var MaterialFactory =
{
    updateSceneMaterial: function (api, sceneMaterialName, libraryMaterialName) {
        //assemble the sketchfab material from the data generated by 3dsMax
        var theMaterial = this.MakeMaterial(sceneMaterialName,libraryMaterialName);
        
        //apply this material to the sketchfab scene
        api.start(this.sketchfabLoopMaterials(api, theMaterial, sceneMaterialName));
    },

    MakeMaterial: function(parentGuid,childGuid ) {
        var materialParameters = MaterialLibrary[parentGuid][childGuid];


        var theMaterial = {
            DiffusePBR:{},
            SpecularPBR:{},
            GlossinessPBR:{},
            EmitColor:{},
            Opacity:{}
        }
        
        
        if ('DiffusePBR_color' in materialParameters) {theMaterial.DiffusePBR.color = this.convertColor(materialParameters.DiffusePBR_color)};
        if ('DiffusePBR_factor' in materialParameters) {theMaterial.DiffusePBR.factor = materialParameters.DiffusePBR_factor};
        if ('DiffusePBR_texture_name' in materialParameters) {theMaterial.DiffusePBR.texture_uid = TextureFactory.GetUidByName(materialParameters.DiffusePBR_texture_name)};
        
        if ('SpecularPBR_color' in materialParameters) {theMaterial.SpecularPBR.color = this.convertColor(materialParameters.SpecularPBR_color)};
        if ('SpecularPBR_factor' in materialParameters) {theMaterial.SpecularPBR.factor = materialParameters.SpecularPBR_factor};
        if ('SpecularPBR_texture_name' in materialParameters) {theMaterial.SpecularPBR.texture_uid = TextureFactory.GetUidByName(materialParameters.SpecularPBR_texture_name)};
        
        if ('GlossinessPBR_factor' in materialParameters) {theMaterial.GlossinessPBR.factor = materialParameters.GlossinessPBR_factor};
        if ('GlossinessPBR_color' in materialParameters) {theMaterial.GlossinessPBR.color = this.convertColor(materialParameters.GlossinessPBR_color)};
        if ('GlossinessPBR_texture_name' in materialParameters) {theMaterial.GlossinessPBR.texture_uid = TextureFactory.GetUidByName(materialParameters.GlossinessPBR_texture_name)};
        
        if ('EmitColor_factor' in materialParameters) {theMaterial.EmitColor.factor = materialParameters.EmitColor_factor};
        if ('EmitColor_color' in materialParameters) {theMaterial.EmitColor.color = this.convertColor(materialParameters.EmitColor_color)};
        
        if ('Opacity_factor' in materialParameters) {theMaterial.Opacity.factor = materialParameters.Opacity_factor};

        return theMaterial;
    },


    sketchfabLoopMaterials: function(api, newMaterialData, sceneMaterialName) {
        api.getMaterialList ( 
            function( err, SketchfabMaterials ) { 
                var n = 0;
                while(SketchfabMaterials[n]) {
                    if (SketchfabMaterials[n].name == sceneMaterialName)
                    {
                        MaterialFactory.setMaterialProperties(api,SketchfabMaterials[n],newMaterialData);
                    }
                    n++;    
                }
            }
        );
    },

    setMaterialProperties: function(api, sceneMaterial, materialParameters) {
        sceneMaterial.channels.AlbedoPBR.enable = false
        sceneMaterial.channels.MetalnessPBR.enable = false
        
        this.SetFullChannel(sceneMaterial.channels.DiffusePBR,materialParameters.DiffusePBR);
        this.SetFullChannel(sceneMaterial.channels.SpecularPBR,materialParameters.SpecularPBR);
        this.SetFullChannel(sceneMaterial.channels.GlossinessPBR,materialParameters.GlossinessPBR);
        this.SetFullChannel(sceneMaterial.channels.EmitColor,materialParameters.EmitColor);
        this.SetFullChannel(sceneMaterial.channels.Opacity,materialParameters.Opacity);

        // if ('Bumpmap_texture_uid' in materialParameters) {sceneMaterial.channels.BumpMap.texture.uid = materialParameters.Bumpmap_texture_uid};
        // if ('Bumpmap_enable' in materialParameters) {sceneMaterial.channels.BumpMap.enable = materialParameters.Bumpmap_enable};
        // if ('Bumpmap_factor' in materialParameters) {sceneMaterial.channels.Bumpmap.factor = materialParameters.Bumpmap_factor};
        
        // if ('NormalMap_factor' in materialParameters) {sceneMaterial.channels.NormalMap.factor = materialParameters.NormalMap_factor};
        // if ('NormalMap_enable' in materialParameters) {sceneMaterial.channels.NormalMap.enable = materialParameters.NormalMap_enable};
        // if ('NormalMap_texture_uid' in materialParameters) {sceneMaterial.channels.NormalMap.texture.uid = materialParameters.NormalMap_texture_uid};
        
        // if ('AOPBR_color' in materialParameters) {sceneMaterial.channels.AOPBR.color = materialParameters.AOPBR_color};
        // if ('AOPBR_factor' in materialParameters) {sceneMaterial.channels.AOPBR.factor = materialParameters.AOPBR_factor};
        // if ('AOPBR_texture' in materialParameters) {sceneMaterial.channels.AOPBR.texture = materialParameters.AOPBR_texture};
        // if ('AOPBR_texCoordUnit' in materialParameters) {sceneMaterial.channels.AOPBR.texture.texCoordUnit = materialParameters.AOPBR_texCoordUnit};
        // console.log('sceneMaterial',sceneMaterial);
        //Apply the change
        api.setMaterial(sceneMaterial, function() {});
        
    },

    SetFullChannel: function(sceneChannel,newChannel){
        sceneChannel.enable = true;
        if ('color' in newChannel) {
            delete sceneChannel.texture
            sceneChannel.color = newChannel.color
        };
        if ('factor' in newChannel) {sceneChannel.factor = newChannel.factor};
        if ('texture_uid' in newChannel && newChannel.texture_uid !== "") {
            delete sceneChannel.color
            var myTexture = this.MakeTexture(newChannel.texture_uid)
            sceneChannel.texture = myTexture
        };
        
    },
    
    convertColor: function(arrColor){
        // var power = 2.339 //this value is tested empirically
        var power = 1.0 //this value is tested empirically
        return [Math.pow(arrColor[0]/255.0,power),Math.pow(arrColor[1]/255.0,power),Math.pow(arrColor[2]/255.0,power)]
    },
    
    MakeTexture: function(uid){
        var texture = {
            magFilter: "LINEAR",
            minFilter: "LINEAR_MIPMAP_LINEAR",
            wrapS: "REPEAT",
            wrapT: "REPEAT",
            textureTarget: "TEXTURE_2D",
            internalFormat: "RGB",
            texCoordUnit: 0,
            uid: uid
        }
        return texture
    },
    
    getList: function(api) {
        api.getMaterialList( function( err, materials ) {
        console.log( materials );
        } );    
    }   
}


var TextureFactory = {
    textures: [],
    
    GetTextureNames: function (api, callback){
        api.getTextureList( function( err, textures ) {
            console.log( textures );
            TextureFactory.textures = textures;
            //some stuff can only be done after we've queried the textures from the sketchfab model
            //for instance set a configuration
            callback();
        } )
        
    },
    
    GetUidByName: function (texturename){
        for (var n = 0; n<TextureFactory.textures.length;n++){
            // console.log(n + ": " + TextureFactory.textures[n].name)
            if (TextureFactory.textures[n].name === texturename)
            {
                //console.log("Found texture at index: " + n)
                return TextureFactory.textures[n].uid;
            }
        }
        //console.log("Coulnd't find " + texturename)
        return "";
    }   
}

var ObjectFactory = {
    filterNodeMapExactName: function(map, nodeName) {
        var items = []
        Object.keys(map).forEach(function(key,index) {
            if (map[key].type == "MatrixTransform" && map[key].name != undefined && map[key].name.toLowerCase() == nodeName.toLowerCase()){
                
                items.push(map[key])
            }
        });
        return items;
    },
        
    filterNodeMapContainsName: function(map, nodeName) {
        var items = []
        Object.keys(map).forEach(function(key,index) {
            if (map[key].type == "MatrixTransform" && map[key].name != undefined && map[key].name.toLowerCase().indexOf(nodeName.toLowerCase()) == 0){
                
                items.push(map[key])
            }
        });
        return items;
    },

    
    SetObjectVisibility: function(api, namePattern, doShow, matchNameExactly) {
        api.getNodeMap( function( err, nodes ) {
            if (err) {
                console.log('Error getting nodes');
                return;
            }else
            {
                var matchedNodeArray = [];
                var patternArray = namePattern.split(','); //the objectnames may be supplied as a comma separated string
                //first find the nodes
                for (var n = 0; n<patternArray.length;n++){
                    var matches;
                    if (matchNameExactly){
                        matches = ObjectFactory.filterNodeMapExactName(nodes, patternArray[n])
                    }else{
                        matches = ObjectFactory.filterNodeMapContainsName(nodes, patternArray[n])
                    }
                    // console.log(matches)
                    matchedNodeArray = matchedNodeArray.concat(matches);
                }
                
                //then hide or show them
                for (var n = 0; n<matchedNodeArray.length;n++){
                    if (doShow) {
                        api.show(matchedNodeArray[n].instanceID);
                    }else{
                      api.hide(matchedNodeArray[n].instanceID);
                    }               
                }
            }
        });     
    },
    
    SetVisibilityByPath: function(api, namePath, doShow) {
        api.getNodeMap( function( err, nodes ) {
            if (err) {
                console.log('Error getting nodes');
                return;
            }else
            {
                //get the first item from the path
                var matches = ObjectFactory.filterNodeMapExactName(nodes,namePath[0])
                if (matches.length > 1) console.log("Found multiple matches for ", namePath[0]);
                
                //loop over its children and find the next item in the namePath
                for (var n = 0; n<matches[0].children.length;n++){
                    if (matches[0].children[n].name === namePath[1]) {
                        if (doShow) {
                            api.show(matches[0].children[n].instanceID);
                        }else{
                          api.hide(matches[0].children[n].instanceID);
                        }               
                        
                    }
                }
            }
        });     
    },
    
    updateObjectVisibility: function(api, setId, slaveId) {
        console.log('setId',setId);
        var objectSet = ObjectSets[setId];
        // var slaves = objectsetParameters["Slaves"];
        
        Object.keys(objectSet).forEach(function(slavekey,index) {
            ObjectFactory.SetVisibilityByPath(api,[setId,slavekey], false)
        });
        
        //turn one on
        ObjectFactory.SetVisibilityByPath(api,[setId,slaveId], true)
    },
    
    setDefaultObjectVisibility: function(api) {
        Object.keys(ObjectSets).forEach(function(setkey,index) {
            var objectSet = ObjectSets[setkey];
            Object.keys(objectSet).forEach(function(slavekey,index) {
                var isDefault = objectSet[slavekey].Default
                ObjectFactory.SetVisibilityByPath(api,[setkey,slavekey], isDefault)
            });
        });

    }
}